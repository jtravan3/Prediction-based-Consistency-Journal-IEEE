\section{Introduction}
Consistency among multiple interleaved transactions in a web service context has always been an issue for researchers and database administrators. Isolation and atomicity are two of the four ACID\footnote{The four traditional database properties are Atomicity, Consistency, Isolation, and Durability} properties that are often relaxed in order to prevent a performance bottleneck. However, when these properties are relaxed, the database can reach an inconsistent state when concurrent transactions interleave incorrectly. This causes data to become corrupted, expensive compensation transactions to be executed, and cascading rollbacks on multiple nodes to be completed before processing can continue. By looking at a practical use case we can more clearly see the issue and the need for a solution that ensures consistency. In Figures \ref{fig:e_com_ticket} \& \ref{fig:bp_env}, we see five web services executing on three different database instances. The first four web services  create a common business process created by the Business Process Execution Language (BPEL) \cite{BPEL}. The web services are: $WS_{1}$ (decrement inventory by product ID), $WS_{2}$ (process payment), $WS_{3}$ (add order by user ID), and $WS_{4}$ (delete user payment info). The goal of the process is to allow a customer to purchase a product from an e-Commerce site. $WS_{5}$ (delete user payment info) and $WS_{3}$ execute within the same database instance. With the relaxed properties in the web service context, concurrent executions of $WS_{5}$ and $WS_{3}$ could cause an inconsistent state on $Node_{3}$. This would then cause a cascading rollback to execute and revert the committed operations of $WS_{1}$ and $WS_{2}$. Existing research shows that many solutions have been presented in the past to address this issue (e.g., \cite{Fekete_SnapshotIso}, \cite{Alrifai_Distributed_Managment}, \cite{Fekete_RAMP}, \cite{Fekete_IsolationSupport}, \cite{Jacobi_Locking}, and \cite{Fekete_Promises}). The most influential research that inspired the prediction-based solution was the Promises Model.

The Promises model presented by Alan Fekete et al. (e.g., \cite{Fekete_IsolationSupport} and \cite{Fekete_Promises}) is an elegant solution that "promises" a particular transaction that the requested resource will be available while allowing concurrent transactions to still execute on that resource. The Promises solution is robust in that it allows the "strengthening" or "weakening" of promises after they have already been made. This allows existing promises on resources to be modified without breaking the existing promise entirely. However, the solution introduces backwards compatibility issues along with a potential bottleneck at the occurrence of registering a promise for a particular transaction. 

Our prediction-based solution allows transactions to build a reputation linked to a category (categories are defined in Definition \ref{transaction_categories} \& \ref{cat_dominance}). The priorities associated with the category impact the transaction's scheduling in order to prevent cascading rollbacks. There are lock behaviors associated with the categories that enable preemptive scheduling in order to increase efficiency. The contributions in the prediction-based solution address the two issues of efficiency and consistency where existing research solutions fall short. Section \ref{sec:problem_def} outlines the problem along with a use-case scenario. Section \ref{sec:existing_research} discusses the existing research that has already taken place in regards to the problem. Section \ref{sec:system_model} outlines the system model for the solution. Section \ref{sec:algorithms} discusses the algorithms needed for the solution and their psuedocode. Section \ref{sec:analysis} provides the formal proofs for the given solution. Section \ref{sec:experimentation} illustrates the simulation results gathered from the prototype.