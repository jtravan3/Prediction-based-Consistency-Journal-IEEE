\subsection{Theoretical Contribution}
% In this section we formally analyze the prediction-based solution and provide the associated theoretical contribution: assurance of consistency for all transactions while preserving an acceptable state of efficiency.
In this section, we formally analyze the prediction-based solution and provide the associated theoretical contribution: assurance of consistency for all transactions while preserving an acceptable state of efficiency. The outline of the analysis is based very closely to the proof of correctness for two-phase locking (2PL) presented by Phil Bernstein \cite[pp. 53-56]{Bernstein_1986:CCR:17299}. 

In order to prove the correctness of the prediction-based solution we prove that each history generated by the prediction-based solution is serializable. However, before we can do that we must characterize the actions involved within the analysis. We say that $T_{1} \rightarrow T_{2}$ ($T_{1}$ \textit{precedes} $T_{2}$) if there are conflicting operations between the two serializable histories contained in $C(H)$. $C(H)$ is the set of all conflicting operations in a serializable history $H$. A \textit{cycle} is present in the serializability graph $SG(H)$ if there exists a path $T_{1} \rightarrow T_{2} \rightarrow ... \rightarrow T_{n} \rightarrow T_{1}$ within the schedule where $n > 1$. By showing that a cycle will never exist within $SG(H)$ we can show that the scheduler used within the prediction-based solution will always produce serializable histories with no cycles, and therefore, preserve consistency.

The prediction-based solution consists of three actions: grant action, decline action, and the elevate action (See Definition \ref{legal_scheduler}). We will analyze the actions involved in the situations described in Sections \ref{sec:t1_higher_than_t2}, \ref{sec:t1_lower_than_t2}, and \ref{sec:t1_equal_to_t2}.

\begin{proposition}
\label{prop:grant}
Let $H$ be a history produced by a prediction-based scheduler. If $o_{i}[x]$ requires a grant action (+) (outlined in Table \ref{tbl:read_lock_compatibility} \& Table \ref{tbl:write_lock_compatibility}) then $o_{i}[x]$ $\notin$ $C(H)$
\end{proposition}

The grant action for an operation $o_{i}[x]$, according to Table \ref{tbl:read_lock_compatibility} \& Table \ref{tbl:write_lock_compatibility}, will only be required when the only locks granted and requested are read-locks. Therefore, there is no conflict and no operations contained within $C(H)$.

In the event that a decline action is required of an operation $p_{i}[x]$, then there exists one or many conflicting operations $q_{j}[x]$ that holds a lock to the required resource $x$. As mentioned in Algorithm \ref{alg:exec_sched}, the scheduler will wait for all unlock operations $qu_{j}[x]$ before granting a lock operation $pl_{i}[x]$.

\begin{proposition}
\label{prop:decline}
Let $H$ be a history produced by  a prediction-based scheduler. If $p_{i}[x]$ requires a decline action (-) (outlined in Table \ref{tbl:read_lock_compatibility} \& Table \ref{tbl:write_lock_compatibility}), then there exists an operation $q_{j}[x]$ $(i \neq j)$ and $p_{i}[x]$ $\in$ $C(H)$ and $q_{j}[x]$ $\in$ $C(H)$. Therefore, $qu_{j}[x] < pl_{i}[x] < p_{i}[x] < pu_{i}[x]$.
\end{proposition}

The final two actions that could potentially be required for database operations are the \textit{elevate action} and the \textit{decline action}. These actions behave very similarly; however, the \textit{elevate action} premptively drops the conflicting locks, so the new operation can obtain a lock to the resource, while the \textit{decline action} waits for all conflicting locks to drop before locking the resource. Therefore, before an operation $p_{1}[x]$ can issue a lock operation $pl_{1}[x]$, all operations within the set $\{Q:q_{1}[x],q_{2}[x],..,q_{n}[x]\}$ must drop their locks. This causes all unlock operations $qu_{i}[x] < pl_{1}[x]$. Although these actions are different, in regards to serializability, they are identical, and therefore, they are combined into one proposition. 

\begin{proposition}
\label{prop:elevate_decline}
Let $H$ be a history produced by a prediction-based scheduler. If $p_{1}[x]$ requires an eleveate action ($\delta$) or a decline action (-) (outlined in Table \ref{tbl:read_lock_compatibility} \& Table \ref{tbl:write_lock_compatibility}) then there exists one or many $q_{i}[x]$ where $q_{i}[x]$ $\in$ $\{Q:q_{1}[x],q_{2}[x],..,q_{n}[x]\}$ and $Q$ $\in$ $C(H)$. Therefore, $\forall$ $q_{i}[x]$ in $Q$ then $qu_{i}[x] < pl_{1}[x] < p_{i}[x] < pu_{i}[x]$.
\end{proposition}

Now that we have formal propositions for each operation within the scheduler, we can formally prove serializability of the prediction-based solution. This proof is done in three steps. First, we show that if $T_{1} \rightarrow T_{2}$ is in $SG(H)$, then there exists a conflicting operation on a resource $x$ where $T_{1}$ must have released its lock on $x$ \textit{before} $T_{2}$ was able to obtain a lock on $x$. The second step shows that for any path $T_{1} \rightarrow T_{2} \rightarrow ... \rightarrow T_{n}$ in $SG(H)$ we can show by transitivity that every $T_{i}$ must release locks for conflicting operations before each $T_{i+1}$. The third and final step uses contradiction to assume that $SG(H)$ contains a cycle $T_{1} \rightarrow T_{2} \rightarrow ... \rightarrow T_{n} \rightarrow T_{1}$. This contradiction shows that it is impossible for a cycle to occur because then $T_{1}$ would have performed an unlock operation before a lock operation. The following lemmas and theorem formalize these three steps.

\begin{lemma}
\label{lemma1}
Let $H$ be a prediction-based history, and suppose $T_{1} \rightarrow T_{2}$ is in $SG(H)$. Then, for some resource $x$ and some conflicting operations $p_{1}[x]$ and $q_{2}[x]$ in $H$, $pu_{1}[x] < ql_{2}[x]$.
\end{lemma}

\textit{Proof:} By having $T_{1} \rightarrow T_{2}$, there must exist conflicting operations $p_{1}[x]$ and $q_{2}[x]$ contained in $C(H)$ where $p_{1}[x] < q_{2}[x]$. Proposition \ref{prop:grant} does not conflict in this case since there are conflicting operations. By looking at Proposition \ref{prop:elevate_decline} we see,

\begin{enumerate}
  \item $pl_{1}[x] < p_{1}[x] < pu_{1}[x]$
  \item $ql_{2}[x] < q_{2}[x] < qu_{2}[x]$
\end{enumerate}

Since the lemma states that $T_{1} \rightarrow T_{2}$ we then have the operation sequence $pl_{1}[x] < p_{1}[x] < pu_{1}[x] < ql_{2}[x] < q_{2}[x] < qu_{2}[x]$, therefore, proving that $pu_{1}[x] < ql_{2}[x]$.\qed

\begin{lemma}
\label{lemma2}
Let $H$ be a prediction-based history, and let $T_{1} \rightarrow T_{2} \rightarrow ... \rightarrow T_{n}$ be a path in $SG(H)$, where $n > 1$. Then, for some resources $x$ and $y$, and some operations $p_{1}[x]$ and $q_{n}[y]$ in $H$, $pu_{1}[x] < ql_{n}[y]$.
\end{lemma}

\textit{Proof:} Rather than the previous proof by contradiction, we will now prove by induction. The base step, where $n = 2$, is proven in Lemma \ref{lemma1}. We begin by supposing the lemma will hold true for $n = k$ where $k \geq 2$ and $n = k + 1$. By induction we see the path $T_{1} \rightarrow T_{2} \rightarrow ... \rightarrow T_{k}$. Induction on the lemma shows that there exists resources $x$ and $z$ and operations $p_{1}[x]$ and $o_{k}[z]$ in $H$ where $pu_{1}[x] < ol_{k}[z]$. To prove for $k + 1$ we use Lemma \ref{lemma1} for $T_{k} \rightarrow T_{k+1}$. Therefore, $\exists$ resource $y$ and conflicting operations $o'_{k}[y]$ and $q_{k+1}[y]$ in $H$ where $o'u_{k}[y] < ql_{k+1}[y]$. Proposition \ref{prop:elevate_decline} shows that $ol_{k}[z] < o'u_{k}[y]$, and therefore, via the transitive property of operation precedence, $pu_{1}[x] < ql_{k+1}[y]$\footnote{\label{note1}Once again, Proposition \ref{prop:grant} does not apply in this situation since there are conflicting operations.}.\qed

\begin{theorem}
\label{theorem1}
prediction-Based (PB) schedulers guarantees serializable execution when used with 2-phase locking (2PL).
\end{theorem}

% \textit{Proof:} prediction-based schedulers work exactly as traditional schedulers in regards to the \textit{grant} and \textit{decline} actions (see Definition \ref{legal_scheduler}). In order to prove the correctness of PB schedulers, we need to show that PB schedulers still guarantees serializable histories when the \textit{elevate} action is performed. We show that the schedule must still remain serializable by reducing the \textit{elevate} action to the combined use of \textit{decline} and \textit{grant} actions.

% Let $T_{1},...,T_{k}$ be the transactions that used conflicting lock on data items such that $\tau(T_{j}) < \tau(T_{i})$ for all $j=1,...k$. But then, after all $T_{j}$'s dropped their lock on the data item the requirement for the \textit{grant} action for $T_{i}$ is reached. That is, the data item is not locked by any transactions in a non-compatible mode (see Definition \ref{compatibility}). \qed
\textit{Proof:} In order to show this is true, we use a proof by contradiction. We assume that, by contradiction, $SG(H)$ contains a cycle where $T_{1} \rightarrow T_{2} \rightarrow ... \rightarrow T_{n} \rightarrow T_{1}$ and $n > 1$. The proof provided by the previous lemma (Lemma \ref{lemma2}) states that for some resources $x$ and $y$ and conflicting operations $p_{1} [x]$ and $q_{2}[y]$ in $H$, $pu_{1}[x] < ql_{2}[y]$. However, this contradicts with Proposition \ref{prop:elevate_decline} due to an unlock operation occurring on a resource before the lock operation\footnote{See footnote \ref{note1}.}. Therefore, the contradiction fails and $ql_{2}[y] < pu_{1}[x]$. \qed